# -*- coding: utf-8 -*-
"""
/***************************************************************************
 PreAndPostFireTiffGeneratorDockWidget
                                 A QGIS plugin
 This Plugin creates a Pre and Post Fire Tiff file depending on the client input
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-03-20
        git sha              : $Format:%H$
        copyright            : (C) 2025 by Diego - Fire2A
        email                : diego@fire2a.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import  QDate, Qt
from qgis.core import QgsProject, QgsRasterLayer
from qgis.gui import QgsMapToolEmitPoint
from qgis.PyQt.QtWidgets import QWidget

import ee
import requests

from osgeo import gdal

def set_band_names(tif_path, band_names):
    ds = gdal.Open(tif_path, gdal.GA_Update)
    if ds:
        for i, name in enumerate(band_names, start=1):
            ds.GetRasterBand(i).SetDescription(name)
        ds.FlushCache()
        ds = None
        print(f"‚úÖ Band names assigned to {tif_path}")
    else:
        print(f"‚ö†Ô∏è {tif_path} can't be opened to edit the bands.")


def ensure_results_folder():
    plugin_dir = os.path.dirname(__file__)
    results_dir = os.path.join(plugin_dir, "results", "images")
    os.makedirs(results_dir, exist_ok=True)
    return results_dir

def get_unique_filepath(base_path):
    """
    If file exists, add numeric suffix (1), (2), etc., until findig one available.
    """
    if not os.path.exists(base_path):
        return base_path

    directory, filename = os.path.split(base_path)
    name, ext = os.path.splitext(filename)

    i = 1
    while True:
        new_filename = f"{name} ({i}){ext}"
        new_path = os.path.join(directory, new_filename)
        if not os.path.exists(new_path):
            return new_path
        i += 1


class FireIgnitionTool(QgsMapToolEmitPoint):
    def __init__(self, iface, callback):
        super().__init__(iface.mapCanvas())
        self.iface = iface
        self.canvas = iface.mapCanvas()
        self.callback = callback
        self.setCursor(Qt.CrossCursor)
        print("üî• FireIgnitionTool Activated. Click on the map to select an ignition point.")

    def canvasReleaseEvent(self, event):
        point = self.toMapCoordinates(event.pos())
        if point:
            print(f"üìç Ignition Point Selected: {point.x()}, {point.y()}")
            self.callback(point)
            self.canvas.unsetMapTool(self)
            print("üîÑ Tool deactivated after the selection.")
        else:
            print("‚ö†Ô∏è Ignition Point couldn't be obtained.")

class TiffGeneratorTab(QWidget):
    #closingPlugin = pyqtSignal()

    def __init__(self, iface, parent=None):
        super().__init__(parent)
        self.iface = iface

        # UI Setup
        self.setWindowTitle("Wildfire TIFF Generator")
        layout = QtWidgets.QVBoxLayout()

        # Punto de ignici√≥n
        self.label_point = QtWidgets.QLabel("Ignition Point: Not Selected")
        self.btn_select_point = QtWidgets.QPushButton("Select an Ignition Point on the Map")
        self.btn_select_point.clicked.connect(self.select_point)

        # Fechas
        self.label_start_date = QtWidgets.QLabel("Start Date:")
        self.start_date = QtWidgets.QDateEdit()
        self.start_date.setCalendarPopup(True)
        self.start_date.setDate(QDate.currentDate())

        self.label_end_date = QtWidgets.QLabel("End Date:")
        self.end_date = QtWidgets.QDateEdit()
        self.end_date.setCalendarPopup(True)
        self.end_date.setDate(QDate.currentDate())

        # √Årea o longitud del recuadro
        self.label_area = QtWidgets.QLabel("Estimated Area of the Wildfire (ha):")
        self.area_input = QtWidgets.QDoubleSpinBox()
        self.area_input.setRange(0, 1000000)
        self.area_input.setSuffix(" ha")

        # Bot√≥n para generar el TIFF
        self.btn_generate = QtWidgets.QPushButton("Generate Pre and Post Fire Tiff Images")
        self.btn_generate.clicked.connect(self.generate_tiff)

        # Agregar widgets al layout
        layout.addWidget(self.label_point)
        layout.addWidget(self.btn_select_point)
        layout.addWidget(self.label_start_date)
        layout.addWidget(self.start_date)
        layout.addWidget(self.label_end_date)
        layout.addWidget(self.end_date)
        layout.addWidget(self.label_area)
        layout.addWidget(self.area_input)
        layout.addWidget(self.btn_generate)

        container = QtWidgets.QWidget()
        container.setLayout(layout)
        
        #self.setWidget(container)
        #layout = QtWidgets.QVBoxLayout(self)
        #self.setLayout(layout)
        #layout.addWidget(container)

        main_layout = QtWidgets.QVBoxLayout(self)
        self.setLayout(main_layout)
        main_layout.addWidget(container)

        self.ignition_point = None
        self.ee_initialize()

    def ee_initialize(self):
        try:
            ee.Initialize()
        except Exception as e:
            print(f"Error at initializing Google Earth Engine: {e}")

    def select_point(self):
        print("üõ† Activating Ignition Point Selection Tool...")
        self.tool = FireIgnitionTool(self.iface, self.set_point)
        self.iface.mapCanvas().setMapTool(self.tool)
        self.iface.mapCanvas().refresh()

    def set_point(self, point):
        if point:
            self.ignition_point = point
            self.label_point.setText(f"Ignition Point: {point.x()}, {point.y()}")
            print(f"‚úÖ Ignition Point Confirmed: {point.x()}, {point.y()}")
        else:
            print("‚ö†Ô∏è Error: Couldn't capture a valid point.")

    def generate_tiff(self):
        if not self.ignition_point:
            print("‚ö†Ô∏è An Ignition Point has not been selected.")
            self.label_point.setText("Select an Ignition Point first")
            return

        start_date = self.start_date.date().toString("yyyy-MM-dd")
        end_date = self.end_date.date().toString("yyyy-MM-dd")
        buffer_distance = self.area_input.value() * 100
        print("üöÄ Iniciating Pre and Post-Fire Image generation...")

        self.get_fire_images(start_date, end_date, buffer_distance)

    def applyScaleFactors(self, image):
        """
        Applies scale factors to Landsat Collection 2 images.

        Parameters:
        image (ee.Image): Input Landsat image.

        Returns:
        ee.Image: Scaled image with reflectance corrections applied.
        """
        opticalBands = image.select('SR_B.*').multiply(0.0000275).add(-0.2)

        hasST_B10 = image.bandNames().contains('ST_B10')
        hasST_B6 = image.bandNames().contains('ST_B6')

        ST_B10 = ee.Algorithms.If(hasST_B10, image.select('ST_B10'), ee.Image(0).rename('ST_B10'))
        ST_B6 = ee.Algorithms.If(hasST_B6, image.select('ST_B6'), ee.Image(0).rename('ST_B6'))

        return image.addBands(opticalBands, overwrite=True).addBands(ee.Image(ST_B10), overwrite=True).addBands(ee.Image(ST_B6), overwrite=True)

    def maskClouds(self, image):
        """
        Masks clouds, cloud shadows, snow, and saturated pixels in Landsat images using the `QA_PIXEL` band.

        Parameters:
        image (ee.Image): The input Landsat image.

        Returns:
        ee.Image: The image with cloud and saturation pixels masked.
        """
        qamask = image.select('QA_PIXEL').bitwiseAnd(int('11111', 2)).eq(0)
        saturationmask = image.select('QA_RADSAT').eq(0)
        return image.updateMask(qamask).updateMask(saturationmask)


    def harmonizeBands(self, image):
        """
        Harmonizes band selection by removing `SR_QA_AEROSOL` if present.

        Parameters:
        image (ee.Image): The input Landsat image.

        Returns:
        ee.Image: The image with consistent band names across sensors.
        """
        bands = image.bandNames()
        filtered = ee.Algorithms.If(
            bands.contains('SR_QA_AEROSOL'),
            image.select(bands.remove('SR_QA_AEROSOL')),
            image
        )
        return ee.Image(filtered)


    def get_INDEX(self, image, sensor):
        """
        Computes NDVI and NBR indices for a Landsat image.

        Parameters:
        image (ee.Image): The input Landsat image.
        sensor (str): The Landsat sensor type ('L5', 'L7', 'L8', 'L9').

        Returns:
        ee.Image: The image with NDVI and NBR bands added.
        """
        bands_dict = {
            'L5': {'NIR': 'SR_B4', 'Red': 'SR_B3', 'SWIR2': 'SR_B7'},
            'L7': {'NIR': 'SR_B4', 'Red': 'SR_B3', 'SWIR2': 'SR_B7'},
            'L8': {'NIR': 'SR_B5', 'Red': 'SR_B4', 'SWIR2': 'SR_B7'},
            'L9': {'NIR': 'SR_B5', 'Red': 'SR_B4', 'SWIR2': 'SR_B7'}
        }
        bands = bands_dict[sensor]

        NDVI = image.expression(
            '(NIR - Red) / (NIR + Red)',
            {'NIR': image.select(bands['NIR']), 'Red': image.select(bands['Red'])}
        ).rename('NDVI')

        NBR = image.expression(
            '((NIR - SWIR2) / (NIR + SWIR2)) * 1000',
            {'NIR': image.select(bands['NIR']), 'SWIR2': image.select(bands['SWIR2'])}
        ).rename('NBR')

        return image.addBands(NDVI).addBands(NBR)


    def renameBands(self, image, sensor):
        """
        Renames bands to maintain consistency across different Landsat sensors.

        Parameters:
        image (ee.Image): The input Landsat image.
        sensor (str): The Landsat sensor type ('L5', 'L7', 'L8', 'L9').

        Returns:
        ee.Image: The image with renamed bands.
        """
        bands_dict = {
            'L5': ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'NDVI', 'NBR', 'QA_PIXEL'],
            'L7': ['SR_B1', 'SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B7', 'NDVI', 'NBR', 'QA_PIXEL'],
            'L8': ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'NDVI', 'NBR', 'QA_PIXEL'],
            'L9': ['SR_B2', 'SR_B3', 'SR_B4', 'SR_B5', 'SR_B6', 'SR_B7', 'NDVI', 'NBR', 'QA_PIXEL']
        }
        bands = bands_dict[sensor]
        new_bands = ['B', 'G', 'R', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR', 'QA_PIXEL']

        available_bands = image.bandNames()
        has_qa_pixel = available_bands.contains('QA_PIXEL')

        return ee.Algorithms.If(
            has_qa_pixel,
            image.select(bands).rename(new_bands),
            image.select(bands[:-1]).rename(new_bands[:-1])
        )

    def adddate(self, image):
        """
        Adds the 'time_start' property to an Earth Engine image.

        Parameters:
        image (ee.Image): The input Earth Engine image.

        Returns:
        ee.Image: The image with the 'time_start' property set.
        """
        return image.set('time_start', image.get('system:time_start'))

    def get_fire_images(self, start_date, end_date, buffer_distance):
        area = max(self.area_input.value(), 0.0001)  
        buffer_size = ee.Number(area).log().multiply(2000).max(3000) 
        buffer_size = ee.Number(163673.1).multiply(ee.Number(1).subtract(ee.Number(-0.001157413).multiply(ee.Number(area).pow(0.5259879)).exp()))  
        buffer_size = buffer_size.multiply(1.5)
        region = ee.Geometry.Point([self.ignition_point.x(), self.ignition_point.y()]).buffer(buffer_size)

        #buffer_size = 1920  # Fixed buffer size: 64 Landsat pixels
        #region = ee.Geometry.Point([self.ignition_point.x(), self.ignition_point.y()]).buffer(buffer_size)
        
        

        L5_col = ee.ImageCollection('LANDSAT/LT05/C02/T1_L2') \
            .map(self.applyScaleFactors).map(self.harmonizeBands).map(self.maskClouds) \
            .map(lambda img: self.get_INDEX(img, 'L5')) \
            .map(lambda img: self.renameBands(img, 'L5'))

        L7_col = ee.ImageCollection('LANDSAT/LE07/C02/T1_L2') \
            .filterDate('1999-01-01', '2003-05-31') \
            .map(self.applyScaleFactors).map(self.harmonizeBands).map(self.maskClouds) \
            .map(lambda img: self.get_INDEX(img, 'L7')) \
            .map(lambda img: self.renameBands(img, 'L7'))

        L8_col = ee.ImageCollection('LANDSAT/LC08/C02/T1_L2') \
            .map(self.applyScaleFactors).map(self.harmonizeBands).map(self.maskClouds) \
            .map(lambda img: self.get_INDEX(img, 'L8')) \
            .map(lambda img: self.renameBands(img, 'L8'))

        L9_col = ee.ImageCollection('LANDSAT/LC09/C02/T1_L2') \
            .map(self.applyScaleFactors).map(self.harmonizeBands).map(self.maskClouds) \
            .map(lambda img: self.get_INDEX(img, 'L9')) \
            .map(lambda img: self.renameBands(img, 'L9'))

        sat = L5_col.merge(L7_col).merge(L8_col).merge(L9_col)

        mosaicpre = sat.filterBounds(region).filterDate(ee.Date(start_date).advance(-365, 'day'), ee.Date(start_date)).map(lambda img: self.adddate(img)).sort('system:time_start', True)
        mosaicpos = sat.filterBounds(region).filterDate(ee.Date(end_date), ee.Date(end_date).advance(180, 'day')).map(lambda img: self.adddate(img)).sort('system:time_start', False)

        pref = mosaicpre.mosaic().clip(region)
        postf = mosaicpos.mosaic().clip(region)

        PREImagen = pref.select(['R', 'G', 'B', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR']).toFloat()
        POSImagen = postf.select(['R', 'G', 'B', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR']).toFloat()
        
        #temp_dir = tempfile.gettempdir()
        #pre_path = os.path.join(temp_dir, f"ImgPreF_{start_date}.tif")
        #post_path = os.path.join(temp_dir, f"ImgPosF_{end_date}.tif")

        results_dir = ensure_results_folder()
        pre_path = get_unique_filepath(os.path.join(results_dir, f"ImgPreF_{start_date}.tif"))
        post_path = get_unique_filepath(os.path.join(results_dir, f"ImgPosF_{end_date}.tif"))


        print(f"üíæ Downloading Images on temporary files: {pre_path} y {post_path}")

        pre_url = PREImagen.getDownloadUrl({
            'scale': 30,
            'bands': ['R', 'G', 'B', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR'],
            'region': region.bounds().getInfo()['coordinates'],
            'crs': 'EPSG:4326',
            'maxPixels': 1e13,
            'format': 'GeoTIFF'
        })

        post_url = POSImagen.getDownloadUrl({
            'scale': 30,
            'bands': ['R', 'G', 'B', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR'],
            'region': region.bounds().getInfo()['coordinates'],
            'crs': 'EPSG:4326',
            'maxPixels': 1e13,
            'format': 'GeoTIFF'
        })

        
        def download_image(url, output_path):
            response = requests.get(url, stream=True)
            if response.status_code == 200:
                with open(output_path, 'wb') as file:
                    for chunk in response.iter_content(1024):
                        file.write(chunk)
                print(f"‚úÖ Image Downloaded: {output_path}")
                return True
            else:
                print(f"‚ö†Ô∏è Error at downloading the image: {url}")
                return False
        
        success_pre = download_image(pre_url, pre_path)
        success_post = download_image(post_url, post_path)

        band_names = ['R', 'G', 'B', 'NIR', 'SWIR1', 'SWIR2', 'NDVI', 'NBR']

        if success_pre:
            set_band_names(pre_path, band_names)

        if success_post:
            set_band_names(post_path, band_names)

        if success_pre and success_post:
            self.add_raster_to_qgis(pre_path, f"Pre-Fire {start_date}")
            self.add_raster_to_qgis(post_path, f"Post-Fire {end_date}")

        print("‚úÖ Temporal Imagees download complete and added to QGIS.")

    def add_raster_to_qgis(self, file_path, layer_name):
        """
        Add a TIFF file to the interface of QGIS.

        Parameters:
        file_path (str): TIFF file path.
        layer_name (str): Name of the layer in QGIS.
        """
        if os.path.exists(file_path):
            layer = QgsRasterLayer(file_path, layer_name, "gdal")
            if layer.isValid():
                QgsProject.instance().addMapLayer(layer)
                print(f"üó∫Ô∏è Layer added to QGIS: {layer_name}")
            else:
                print(f"‚ö†Ô∏è Error: Couldn't load the layer {layer_name}")
        else:
            print(f"‚ö†Ô∏è File doesn't exist: {file_path}")